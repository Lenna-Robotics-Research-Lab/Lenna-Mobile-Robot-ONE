/**
 * @file packet_handler.c
 * @brief This module handles the communication protocol for the robot.
 *
 * It provides functions for establishing a handshake, transmitting sensor data packets,
 * and receiving/validating command packets.
 *
 * @author Lenna Robotics Research Laboratory, Autonomous Systems Research Branch, Iran University of Science and Technology
 * @date June 5, 2024
 * @version 1.0
 * @link https://github.com/Lenna-Robotics-Research-Lab
 */

#include "odometry.h"
#include "packet_handler.h"
#include "usart.h"
#include "stdlib.h"
#include "mcu_config.h"
#include "imu.h"
#include "string.h"

/*-------------------------- Code Body ---------------------------------------- */
/**
 * Definition of  CRC Tables
 * CRC lookup tables for calculating and comparing CRC values
 */
static const uint8_t table_crc_hi[] = {
	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
	0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
	0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
	0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1,
	0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1,
	0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
	0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40,
	0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1,
	0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
	0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40,
	0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
	0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
	0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
	0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
	0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
	0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
	0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40,
	0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1,
	0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
	0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
};

/* Table of CRC values for low-order byte */
static const uint8_t table_crc_lo[] = {
	0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06,
	0x07, 0xC7, 0x05, 0xC5, 0xC4, 0x04, 0xCC, 0x0C, 0x0D, 0xCD,
	0x0F, 0xCF, 0xCE, 0x0E, 0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09,
	0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9, 0x1B, 0xDB, 0xDA, 0x1A,
	0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC, 0x14, 0xD4,
	0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3,
	0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3,
	0xF2, 0x32, 0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4,
	0x3C, 0xFC, 0xFD, 0x3D, 0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A,
	0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38, 0x28, 0xE8, 0xE9, 0x29,
	0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 0x2E, 0x2F, 0xEF, 0x2D, 0xED,
	0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26,
	0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60,
	0x61, 0xA1, 0x63, 0xA3, 0xA2, 0x62, 0x66, 0xA6, 0xA7, 0x67,
	0xA5, 0x65, 0x64, 0xA4, 0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F,
	0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB, 0x69, 0xA9, 0xA8, 0x68,
	0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA, 0xBE, 0x7E,
	0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5,
	0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71,
	0x70, 0xB0, 0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92,
	0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C,
	0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B,
	0x99, 0x59, 0x58, 0x98, 0x88, 0x48, 0x49, 0x89, 0x4B, 0x8B,
	0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
	0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42,
	0x43, 0x83, 0x41, 0x81, 0x80, 0x40
};

/**
 * @brief Initializes the packet handling module.
 * @param packet Pointer to the packet configuration structure.
 *
 * This function initiates a non-blocking UART receive in interrupt mode,
 * waiting for the start of an incoming packet.
 */
void LRL_Packet_Init(packet_cfgType *packet)
{
	HAL_UART_Receive_IT(packet->huart, packet->buffer, packet->min_pkt_lenght);
}


/**
 * @brief Performs a handshake to establish a reliable connection.
 * @param packet Pointer to the packet configuration structure.
 *
 * The microcontroller repeatedly sends a signature message ("LENNA") and waits
 * for a specific acknowledgment from the host (`0x45`). This ensures the
 * communication link is ready before transmitting data.
 */
void LRL_Packet_Handshake(packet_cfgType *packet)
{
	uint8_t _ack_data[5] = {0x4C, 0x45, 0x4E, 0x4E, 0x41};
	int _out = 0;
	while(_out != 1)
	{
		HAL_UART_Transmit_IT(packet->huart, _ack_data, 5);
		HAL_Delay(500);
		HAL_UART_Receive(packet->huart, &packet->ack, 1, 10);
		if(packet->ack == 0x45)
		{
			_out = 1;
		}
	}
	// Transmit a confirmation message to the host.
	uint8_t _msg[] = "The transmission has been established";
	HAL_UART_Transmit(&huart1, _msg, sizeof(_msg)-1, 10);
}


/**
 * @brief Updates a CRC-16 checksum for a block of data.
 * @param crc_accum The initial CRC value (0 for a new calculation).
 * @param data_blk_ptr Pointer to the data block.
 * @param data_blk_size Size of the data block in bytes.
 * @param crc_final A reference to store the final CRC value.
 *
 * This function calculates the CRC-16 checksum using a pre-computed lookup table
 * and updates the final CRC value passed by reference.
 * @warning The function modifies the value pointed to by `crc_final` and should be
 * used carefully. The arguments `crc_accum` and `crc_final` are used inconsistently
 * and should be reviewed.
 */
void LRL_Packet_UpdateCRC(uint8_t *data_blk_ptr, uint16_t data_blk_size, unsigned short crc_final )
{

	uint16_t _crc_accum = 0;
	uint16_t i, j;
	static const uint16_t _crc_table[256] = { 0x0000,
	0x8005, 0x800F, 0x000A, 0x801B, 0x001E, 0x0014, 0x8011,
	0x8033, 0x0036, 0x003C, 0x8039, 0x0028, 0x802D, 0x8027,
	0x0022, 0x8063, 0x0066, 0x006C, 0x8069, 0x0078, 0x807D,
	0x8077, 0x0072, 0x0050, 0x8055, 0x805F, 0x005A, 0x804B,
	0x004E, 0x0044, 0x8041, 0x80C3, 0x00C6, 0x00CC, 0x80C9,
	0x00D8, 0x80DD, 0x80D7, 0x00D2, 0x00F0, 0x80F5, 0x80FF,
	0x00FA, 0x80EB, 0x00EE, 0x00E4, 0x80E1, 0x00A0, 0x80A5,
	0x80AF, 0x00AA, 0x80BB, 0x00BE, 0x00B4, 0x80B1, 0x8093,
	0x0096, 0x009C, 0x8099, 0x0088, 0x808D, 0x8087, 0x0082,
	0x8183, 0x0186, 0x018C, 0x8189, 0x0198, 0x819D, 0x8197,
	0x0192, 0x01B0, 0x81B5, 0x81BF, 0x01BA, 0x81AB, 0x01AE,
	0x01A4, 0x81A1, 0x01E0, 0x81E5, 0x81EF, 0x01EA, 0x81FB,
	0x01FE, 0x01F4, 0x81F1, 0x81D3, 0x01D6, 0x01DC, 0x81D9,
	0x01C8, 0x81CD, 0x81C7, 0x01C2, 0x0140, 0x8145, 0x814F,
	0x014A, 0x815B, 0x015E, 0x0154, 0x8151, 0x8173, 0x0176,
	0x017C, 0x8179, 0x0168, 0x816D, 0x8167, 0x0162, 0x8123,
	0x0126, 0x012C, 0x8129, 0x0138, 0x813D, 0x8137, 0x0132,
	0x0110, 0x8115, 0x811F, 0x011A, 0x810B, 0x010E, 0x0104,
	0x8101, 0x8303, 0x0306, 0x030C, 0x8309, 0x0318, 0x831D,
	0x8317, 0x0312, 0x0330, 0x8335, 0x833F, 0x033A, 0x832B,
	0x032E, 0x0324, 0x8321, 0x0360, 0x8365, 0x836F, 0x036A,
	0x837B, 0x037E, 0x0374, 0x8371, 0x8353, 0x0356, 0x035C,
	0x8359, 0x0348, 0x834D, 0x8347, 0x0342, 0x03C0, 0x83C5,
	0x83CF, 0x03CA, 0x83DB, 0x03DE, 0x03D4, 0x83D1, 0x83F3,
	0x03F6, 0x03FC, 0x83F9, 0x03E8, 0x83ED, 0x83E7, 0x03E2,
	0x83A3, 0x03A6, 0x03AC, 0x83A9, 0x03B8, 0x83BD, 0x83B7,
	0x03B2, 0x0390, 0x8395, 0x839F, 0x039A, 0x838B, 0x038E,
	0x0384, 0x8381, 0x0280, 0x8285, 0x828F, 0x028A, 0x829B,
	0x029E, 0x0294, 0x8291, 0x82B3, 0x02B6, 0x02BC, 0x82B9,
	0x02A8, 0x82AD, 0x82A7, 0x02A2, 0x82E3, 0x02E6, 0x02EC,
	0x82E9, 0x02F8, 0x82FD, 0x82F7, 0x02F2, 0x02D0, 0x82D5,
	0x82DF, 0x02DA, 0x82CB, 0x02CE, 0x02C4, 0x82C1, 0x8243,
	0x0246, 0x024C, 0x8249, 0x0258, 0x825D, 0x8257, 0x0252,
	0x0270, 0x8275, 0x827F, 0x027A, 0x826B, 0x026E, 0x0264,
	0x8261, 0x0220, 0x8225, 0x822F, 0x022A, 0x823B, 0x023E,
	0x0234, 0x8231, 0x8213, 0x0216, 0x021C, 0x8219, 0x0208,
	0x820D, 0x8207, 0x0202 };

	for (j = 0; j < data_blk_size; j++)
	{
	i = ((uint16_t)(_crc_accum >> 8) ^ *data_blk_ptr++) & 0xFF;
	_crc_accum = (_crc_accum << 8) ^ _crc_table[i];
	}
	crc_final = _crc_accum;
}


/**
 * @brief Assembles and transmits a data packet via UART.
 * @param packet Pointer to the packet configuration structure.
 * @param odom Pointer to the odometry state structure.
 * @param imu Pointer to the IMU state structure.
 *
 * This function packs sensor and odometry data into a defined packet format,
 * calculates the CRC checksum, and transmits the complete packet using a
 * non-blocking, interrupt-driven UART transfer.
 */
void LRL_Packet_TX(packet_cfgType *packet, odom_cfgType *odom, imu_statetype *imu)
{
	unsigned short _tmp_crc = 0;

	// Start of packet markers.
	packet->buffer[0] = 0xFF;
	packet->buffer[1] = 0xFF;

	// Message ID and payload length.
	packet->buffer[2] = 0x01;
	packet->buffer[3] = 0x20; // Payload size is 32 bytes.

	// Pack odometry data.
	packet->buffer[4] = (uint8_t)(odom->vel.left >> 8);
	packet->buffer[5] = (uint8_t)(odom->vel.left & 0x00FF);
	packet->buffer[6] = (uint8_t)(odom->vel.right >> 8);
	packet->buffer[7] = (uint8_t)(odom->vel.right & 0x00FF);
	packet->buffer[8] = (uint8_t)(odom->dist.left >> 8);
	packet->buffer[9] = (uint8_t)(odom->dist.left & 0x00FF);
	packet->buffer[10] = (uint8_t)(odom->dist.right >> 8);
	packet->buffer[11] = (uint8_t)(odom->dist.right & 0x00FF);

	// Pack IMU accelerometer data.
	packet->buffer[12] = (uint8_t)(imu->accel.x_calibrated >> 8);
	packet->buffer[13] = (uint8_t)(imu->accel.x_calibrated & 0x00FF);
	packet->buffer[14] = (uint8_t)(imu->accel.y_calibrated >> 8);
	packet->buffer[15] = (uint8_t)(imu->accel.y_calibrated & 0x00FF);
	packet->buffer[16] = (uint8_t)(imu->accel.z_calibrated >> 8);
	packet->buffer[17] = (uint8_t)(imu->accel.z_calibrated & 0x00FF);

	// Pack IMU gyroscope data.
	packet->buffer[18] = (uint8_t)(imu->gyro.x_calibrated >> 8);
	packet->buffer[19] = (uint8_t)(imu->gyro.x_calibrated & 0x00FF);
	packet->buffer[20] = (uint8_t)(imu->gyro.y_calibrated >> 8);
	packet->buffer[21] = (uint8_t)(imu->gyro.y_calibrated & 0x00FF);
	packet->buffer[22] = (uint8_t)(imu->gyro.z_calibrated >> 8);
	packet->buffer[23] = (uint8_t)(imu->gyro.z_calibrated & 0x00FF);

	// Pack IMU angular position data.
	packet->buffer[24] = (uint8_t)(imu->angle.x >> 8);
	packet->buffer[25] = (uint8_t)(imu->angle.x & 0x00FF);
	packet->buffer[26] = (uint8_t)(imu->angle.y >> 8);
	packet->buffer[27] = (uint8_t)(imu->angle.y & 0x00FF);

	// Pack magnetometer heading data.
	packet->buffer[28] = (uint8_t)(imu->mag.heading >> 8);
	packet->buffer[29] = (uint8_t)(imu->mag.heading & 0x00FF);

	// Calculate and append CRC to the packet.
	// Note: The original function has a logical error as it won't update the CRC value.
	// It's assumed to be corrected in a functional version of the code.
	LRL_Packet_UpdateCRC(packet->buffer, 30, _tmp_crc);

	packet->buffer[30] = (uint8_t)(_tmp_crc >> 8);
	packet->buffer[31] = (uint8_t)(_tmp_crc & 0x00FF);

	// Transmit the complete packet.
	HAL_UART_Transmit_IT(packet->huart, packet->buffer, 32);
}


/**
 * @brief Handles incoming UART data packets.
 * @param packet Pointer to the packet configuration structure.
 *
 * This function processes received packets, validates their integrity using a CRC,
 * and extracts the control data if the packet is valid.
 */
void LRL_Packet_RX(packet_cfgType *packet)
{
	if(packet->byteReady)
	{
		packet->byteReady = 0;
		uint8_t _total_pkt_len, _remain_pkt_length, _crc_packet_len;
		unsigned short _temp_crc = 0;

		// The third byte of the packet holds the payload length.
		_total_pkt_len = packet->buffer[2] + 3;
		_remain_pkt_length = _total_pkt_len - packet->min_pkt_lenght;

		// Receive the rest of the packet's payload.
		if(_remain_pkt_length)
		{
			HAL_UART_Receive(packet->huart, &packet->buffer[3], _remain_pkt_length, 1);
		}

		// Validate the received packet using CRC.
		_crc_packet_len = _total_pkt_len - 2;
		LRL_Packet_UpdateCRC(packet->buffer, _crc_packet_len, _temp_crc);

		if(_temp_crc == ((packet->buffer[_total_pkt_len - 2]<<8)|(packet->buffer[_total_pkt_len - 1])))
		{
			packet->dataValid = 1;
		}
		else
		{
			packet->dataValid = 0;
		}

		// Extract control data if the packet is valid.
		if(packet->dataValid)
		{
			packet->vel_data.left_velocity = (int16_t)((packet->buffer[4] << 8) | packet->buffer[5]);
			packet->vel_data.right_velocity = (int16_t)((packet->buffer[6] << 8) | packet->buffer[7]);
		}

		// Clear the buffer and re-arm the UART receive interrupt for the next packet.
		memset(packet->buffer, 0, packet->max_pkt_lenght*sizeof(packet->buffer[0]));
		HAL_UART_Receive_IT(packet->huart, packet->buffer, packet->min_pkt_lenght);
	}
}

void LRL_Protocol_RX(packet_cfgType *packet)
{
	if(packet->byteReady == 0)
	{
		if(packet->buffer[1] == 0x00)
		{
			/*
			 * Reserved protocol code for testing. Normally no packet is expected to
			 * have the 0x00 command tag.
			 */
			uint8_t full_length = packet->buffer[2] + 3;
			packet->byteReady = 1;
			// If we only received the header, get the rest
			if(full_length > packet->min_pkt_lenght)
			{
				HAL_UART_Receive_IT(packet->huart,
								   &packet->buffer[packet->min_pkt_lenght],
								   full_length - packet->min_pkt_lenght);
			}
			else
			{
				packet->byteReady = 1;

				// Re-arm for next packet header
				HAL_UART_Receive_IT(packet->huart, packet->buffer, packet->min_pkt_lenght);
			}
		}
		else if(packet->buffer[1] == 0x01)
		{
			// Second stage: full packet received or invalid header
			packet->byteReady = 1;
	//            HAL_UART_Transmit(packet->huart, "HERE2", sizeof("HERE2"), 10);

			// CRITICAL: Re-arm for next packet header
			HAL_UART_Receive_IT(packet->huart, packet->buffer, packet->min_pkt_lenght);
		}
	}
	else
	{
		HAL_UART_Receive_IT(packet->huart, packet->buffer, packet->min_pkt_lenght);
	}
}

